%% Thesis Template of Chinese Academy of Sciences
%%   for using CASthesis package with LaTeX2e
%%
%% Created by Ling-Yun Wu <aloft@ctex.org>
%%
%% $Id: template.tex,v 1.10 2007/01/09 05:10:46 aloft Exp $

%\documentclass{article}
%\documentclass[dvipdfm]{CASthesis}
\documentclass[pdftex]{CASthesis}
% 可选参数：
% notypeinfo 取消扉页的LaTeX版本信息
%
% 下面三个选一个：
% dvipdfm 使用 dvipdfm(x) 生成最终的 PDF 文档 (缺省设置）
% dvips 使用 dvips 生成最终的 PS 文档
% pdftex 使用 pdfLaTeX 生成最终的 PDF 文档


% 设置图形文件的搜索路径
\graphicspath{{chapter/}{pic/}}

% 取消链接的颜色（黑白打印时）
%\hypersetup{colorlinks=false}

% 小节标题靠左对齐
%\CTEXsetup[format+={\flushleft}]{section}

\usepackage[english]{babel}
\usepackage{subfigure}
\usepackage{multirow}
\usepackage{caption}
\begin{document}

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 正文部分
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\mainmatter

\section{相关工作}
\subsection{大量点光源光照}
为什么要渲染大量点光源？在对场景做渲染时，由于场景中的光源数量可能很多，甚至是动态的光源时，同时保证渲染效果和渲染速度仍是比较困难的。现如今有很多关于在场景中实时绘制大量点光源的算法，比如Forward+算法\cite{harada2012forward+}里将屏幕分块来进行光源剔除，而为了解决分块中包含的光源太多以及深度不连续等等问题，分簇着色\cite{Olsson2012Clustered} 在分块着色的基础上，将分块从二维的屏幕空间延伸到三维的观察空间，在深度上进一步划分。LLL算法\cite{bezrati2018real}为每个像素建立了一个GPU光源链表，在进行光源剔除的同时使得在延迟渲染中，可以在一遍Pass中同时渲染不透明和半透明物体，让半透明物体和粒子的光照渲染变得更加简单。但是这些算法都是在对大量的点光源进行光源剔除，当点光源的光照模型不是Phong模型，而是诸如GGX BRDF等基于物理的复杂光照模型时，渲染效率依然会很低。

\subsection{实时光照模型}
用于点光源渲染的光照模型有很多。Bouknight曾提出Lambert模型\cite{Bouknight1970A}，但是只适用于粗糙表面。Phong模型加入了镜面反射，而Blinn-Phong模型\cite{blinn1977models}是对Phong模型的扩展，修正了Phong模型的镜面光效果，计算效率也更高。但是它们都不符合物理规律。在基于物理的渲染中，通常使用一个双向反射分布函数\cite{Nicodemus1965Directional} 来表示物体表面的反射辐射度(radiance)占入射辐照度(irradiance)的比率。完全遵循物理规律的BRDF函数会非常复杂，实际渲染中通常都是使用近似的方法，不同的近似方法会形成不同的BRDF模型。如今已经有很多比较理想的经验BRDF模型\cite{Montes2012AnOO}，比如基于分层理论的Granier-Heidrich BRDF模型\cite{Granier2003A}、 基于几何观点的Oren-Nayar模型\cite{Nayar1995Visual}、基于实验的Schlick BRDF 模型\cite{schlick1994inexpensive}等等，不过在实时渲染以及游戏引擎中使用最多的还是Cook等人在Beckman\cite{Beckmann1963The}和Torrance-Sparrow\cite{torrance1967theory}的基础上提出的基于微面元理论的Cook-Torrance BRDF 模型\cite{cook1982reflectance}，该理论认为任何表面都是由非常小的微观面元组成，每个微观面元都有自己的粗糙度。除此之外还有很多Cook-Torrance BRDF模型的变种\cite{Pont2002Bidirectional}\cite{schlick1994inexpensive}\cite{kelemen2001microfacet}，该模型也被实验证明能够很好地模拟真实的表面\cite{Ngan2005Experimental}。 对于该模型中的微观面元法线分布函数，比较流行的是Beckmann\cite{Beckmann1963The}、Phong\cite{phong1975illumination}以及GGX\cite{Walter2007Microfacet}等分布函数，但是只有GGX 分布才会在高光中心处衰减较快，远离高光中心后衰减会变得很慢，使得GGX高光产生拖尾效应，而这一点非常符合现实情况\cite{Matusik2003A}。而微观面元几何遮挡函数(bidirectional shadowing-masking function)可以通过法线分布函数和史密斯阴影函数（Smith Shadowing function）得到，但是史密斯阴影函数是假设入射遮挡（shadowing）和出射遮挡（masking）是不相关的，不过近年来更流行的是Lagarde等人\cite{lagarde2014moving}提出的更精确的几何遮挡函数，它考虑了入射遮挡和出射遮挡的相关性。对于漫反射BRDF，曾经比较流行的是lambert BRDF模型\cite{Bouknight1970A}，但是由于它失去了方向性，无法有效反映回射反射(retro-reflection)的效果，Disney提出了一个新的漫反射经验模型\cite{burley2012physically}。

\subsection{Linearly Transformed cosine}
由于基于物理的BRDF模型公式复杂并且计算量较大，所以Eric Heitz等人在实现面光源光照时，提出了一种名为Linearly Transformed Cosine的数学方法，用一个线性矩阵和余弦分布来拟合BRDF分布。本文工作受此启发，使用Linearly Transformed Cosine来实现基于物理的大量点光源光照，以达到降低计算量的目的。

\section{算法部分}
本文算法要实现的目标是：用LTC的方式来近似实现多点光源下基于物理的光照效果，同时渲染效率要比常用的BRDF方式更高。
\subsection{反射率方程}
为了实现更真实的渲染效果，如今业界广泛使用如下的反射率方程来实现基于物理的光照渲染：
\begin{equation}
\label{eq:ReflectionFunction}
L_o(p,\omega_o)=\int_{\Omega}f_r(p,\omega_i,\omega_o)L_i(p,w_i)n\cdot \omega_id\omega_i
\end{equation}

其中$p$着色点，n是表面法线，$\omega_o$为观察方向，$\omega_i$为光线入射方向，$L_i$是来自$\omega_i$方向上的辐射亮度，$L_o$是着色点在上半球空间接受到的辐射度，$f_r$是双向反射分布函数（BRDF），描述了反射方向上的辐射照度与入射方向上的辐射照度的比率。
当前主流的游戏引擎（如Unity、Unreal等）都在使用基于微面元理论的BRDF模型：
\begin{equation}
\label{eq:BRDFFunction}
f_r(\omega_i,\omega_o)=f_d+\frac{DFG}{4(\omega_o\cdot n)(\omega_i\cdot n)}
\end{equation}

其中$f_d$是漫反射系数，D是描述微观面元法线分布的函数，F是描述表面菲涅尔反射的函数，G是描述微观面元之间几何遮挡比率的函数。

所以我们通常使用的反射率方程是：
\begin{equation}
L_o(p,\omega_o)=\int_\Omega(f_d+\frac{DFG}{4(\omega_o\cdot n)(\omega_i\cdot n)})L_i(p,\omega_i)n\cdot\omega_id\omega_i
\end{equation}

本文采用的D、F、G函数与Unity引擎内部使用的函数一致。

对于法线分布函数D本文采用GGX分布\cite{Walter2007Microfacet}
\begin{equation}
\label{eq:GGXD}
D=\frac{\alpha^2\chi^+(\theta_h)}{\pi\cos^4\theta_h(\alpha^2+\tan^2\theta_h)^2}
\end{equation}

其中$h$表示中间向量，$\alpha$表示表面粗糙度，$\theta_h$是法向量$n$与中间向量$h$的夹角，并且：
\begin{equation}
\chi^+(\theta_h)=
\begin{cases}
1, &\theta_h>0 \\
0, &\theta_h<0
\end{cases}
\end{equation}

对于菲涅尔函数本文采用渲染领域中常用的Schlick近似模型\cite{schlick1994inexpensive}：
\begin{equation}
\label{eq:Fresnel}
F=F_0+(1-F_0)(1-(h\cdot \omega_o)^5)
\end{equation}
其中$F_0$为入射光垂直表面时的菲涅尔反射率的值，即表面的基础反射率。

对于几何遮挡函数G，本文采用了近年来越来越多的引擎开始使用的更精确的一种遮挡函数\cite{lagarde2014moving}：
\begin{equation}
\label{eq:GeometryShadow}
G=\frac{\chi^+(\omega_o\cdot h)\chi^+(\omega_i\cdot h)}{1+\Lambda(\omega_o)+\Lambda(\omega_i)}
\end{equation}
其中：
\begin{equation}
\Lambda(m)=\frac{-1+\sqrt{1+\alpha^2\tan^2(\theta_m)}}{2}
\end{equation}
其中$\theta_m$是向量$m$和法线$n$之间的夹角。

对于式-\ref{eq:BRDFFunction}中的漫反射项$f_d$，本文采用Disney最新使用的漫反射模型\cite{burley2012physically}：
\begin{equation}
\label{eq:DisneyDiffuse}
f_d = \frac{c}{\pi}(1+(F_D-1)(1-cos\theta_l)^5)(1+(F_D-1)(1-cos\theta_v)^5)
\end{equation}
其中$\theta_l$是$\omega_i$和法线$n$的夹角，$\theta_v$是$\omega_o$和$n$的夹角，并且:
\begin{equation}
F_D=0.5+2\alpha\cos^2\theta_d
\end{equation}
其中$\theta_d$是入射向量$\omega_i$和中间向量$h$的夹角。

可以初步看到，渲染时因为要按照上诉公式去分别计算D、F、G项以及$f_d$，再得到最终的辐射度$L_o$，所以即使是在一个单点光源的环境下，着色点渲染时所需要的计算量也很大。

\subsection{使用LTC方法近似BRDF积分}
Eric Heitz等人在解决区域光源光照时提出了一种名为线性转换余弦分布（Linear Transform consin）的数学方法\cite{Heitz2016Real}，来近似计算BRDF积分。如图\ref{fig:Distribution Approxmation}所示：
\begin{figure}
	\centering
	\includegraphics[width=0.5\columnwidth]{DistributionApproxmation.png}
    \captionsetup{font={small}}
	\caption{使用余弦分布乘上矩阵M来近似BRDF分布}
	\label{fig:Distribution Approxmation}
\end{figure}
图中，上面是在某种粗糙度$\alpha$以及观察向量$\omega_o$下的BRDF分布，分布函数如下：
\begin{equation}
\label{eq:BRDFDistribution}
B_s(\omega_i) =  \frac{DFG}{4(\omega_o\cdot n)(\omega_i\cdot n)}n\cdot\omega_i
\end{equation}

下面是一个截断余弦（Clamped Cosine）分布，它的分布函数如下：
\begin{equation}
\label{eq:ClampedCosine}
C(\omega_i=(x,y,z)) = \frac{1}{\pi}max(0,z)
\end{equation}

其中$\omega_i$是单位向量。

作者提出可以在下面的余弦分布上乘以一个3x3的线性变换矩阵$M_s$，来近似得到上面的BRDF分布。该矩阵$M_s$的形式如下：
\begin{equation}
  M_s=\begin{bmatrix}
    a & 0 & b \\
    0 & c & 0 \\
    d & 0 & 1
  \end{bmatrix}
\end{equation}

以二维纹理的纹理坐标u作为观察角度$\theta_o$，以纹理坐标v作为粗糙度$\alpha$，拟合出不同的矩阵$M_s$。可以将预计算好的$M_s$的逆矩阵存入二维纹理坐标(u,v)所对应的纹素中。作者提出在BRDF分布上对一个多边形光源区域$P$的积分，等效于在余弦分布上对另一个多边形区域$P_c$的积分（多边形$P_c$是对多边形$P$乘上矩阵$M_s$的逆矩阵之后，得到的新的多边形）：
\begin{equation}
\label{eq:IntegrationApproxmation}
\int_PB_s(\omega)d\omega=\int_{P_c}C(\omega_s)d\omega_s
\end{equation}
其中$\omega$是在BRDF分布下的光线入射向量，而$\omega_s$是$\omega$乘上矩阵$M_s^{-1}$作线性变换之后的新的入射向量。

\subsection{使用LTC方法来计算单点光源光照}
将上式-\ref{eq:IntegrationApproxmation}中的$\omega$看作单位球上的无限小的面积，那么上式中对$\omega$的积分实际上就是在对一个点光源进行光照计算。那么一个着色点接受到来自$\omega$方向上的点光源的镜面辐射度为：
\begin{equation}
\label{eq:MistakeEquation}
L_s = B_s(\omega)=C(\omega_s)
\end{equation}
其中$\omega_s$是对$\omega$乘上线性余弦变换矩阵$M_s$的逆矩阵之后得到的新的向量，即：
\begin{equation}
\label{eq:SpecularOmega}
\omega_s = M_s^{-1}\omega
\end{equation}
但是实际上在式\ref{eq:IntegrationApproxmation}中无限小的$d\omega$和$d\omega_s$的面积是不一样的（因为$d\omega_s$是$d\omega$作线性变换得到的，线性变换的过程中会改变面积大小）。所以式\ref{eq:MistakeEquation}是不成立的，还需要乘上两个$\omega$的面积比例：
\begin{equation}
\label{eq:RightEquation}
L_s = B_s(\omega)=C(\omega_s)\frac{\partial\omega_s}{\partial\omega}
\end{equation}
作者在文中已经给出了$\frac{\partial\omega_s}{\partial\omega}$的推导结果，即：
\begin{equation}
\label{eq:RightEquation}
B_s(\omega)=C(\omega_s)\frac{\partial\omega_s}{\partial\omega} =C(\omega_s)\frac{|M_s^{-1}|}{||M_s^{-1}\omega||^3}
\end{equation}

同样的，本文对式\ref{eq:DisneyDiffuse}中的Disney漫反射也使用LTC方法拟合出另一个线性余弦变换矩阵$M_d$。那么一个着色点接受到来自$\omega$方向上的点光源的漫反射辐射度为：
\begin{equation}
\label{eq:DiffuseApproximation}
L_d=B_d(\omega)= C(\omega_d)\frac{|M_d^{-1}|}{||M_d^{-1}\omega||^3}
\end{equation}
其中：
\begin{equation}
\label{eq:DiffuseDistribution}
B_d(\omega)=f_dn\cdot\omega_i
\end{equation}
\begin{equation}
\label{eq:DiffuseOmega}
\omega_d = M_d^{-1}\omega
\end{equation}

所以，综合式\ref{eq:BRDFFunction}、式\ref{eq:BRDFDistribution}、式\ref{eq:RightEquation}、式\ref{eq:DiffuseApproximation}以及式\ref{eq:DiffuseDistribution}，着色点接受到的来自$\omega$方向上的点光源的辐射度为：
\begin{equation}
\label{eq:LTCSinglePointLight}
L_o=f_rL_in\cdot\omega=(B_s(\omega)+B_d(\omega))L_i=(C(\omega_s)\frac{|M_s^{-1}|}{||M_s^{-1}\omega||^3}+C(\omega_d)\frac{|M_d^{-1}|}{||M_d^{-1}\omega||^3})L_i
\end{equation}

由式\ref{eq:ClampedCosine}、式\ref{eq:SpecularOmega}、式\ref{eq:DiffuseOmega}可以得到：
\begin{equation}
C(\omega_s)=\frac{(M_s^{-1}\omega).z}{||M_s^{-1}\omega||}
\end{equation}
\begin{equation}
C(\omega_d)=\frac{(M_d^{-1}\omega).z}{||M_d^{-1}\omega||}
\end{equation}
代入式\ref{eq:LTCSinglePointLight}可得：
\begin{equation}
\label{eq:FinalEquation4SPL}
L_o=\frac{\omega_s.z}{(\omega_s\cdot\omega_s)^2}|M_s^{-1}|L_i+\frac{\omega_d.z}{(\omega_d\cdot\omega_d)^2}|M_d^{-1}|L_i
\end{equation}

可以看到，借助LTC方法来计算点光源的辐照度，只需要计算几次向量乘法、平方以及矩阵的行列式就可以了，计算量相当简单（不需要求矩阵的逆，因为本文在预计算的二维纹理中存储的就是$M^{-1}$，而不是$M$）。

\subsection{使用LTC方法来计算多个点光源光照}
由式\ref{eq:FinalEquation4SPL}可得，着色点在多个点光源光照下的辐射照度为：
\begin{equation}
L_o=\sum_{\omega_i}(\frac{\omega_s.z}{(\omega_s\cdot\omega_s)^2}|M_s^{-1}|L_i+\frac{\omega_d.z}{(\omega_d\cdot\omega_d)^2}|M_d^{-1}|L_i)
\end{equation}
其中$\omega_s=M_s^{-1}\omega_i$、$\omega_d=M_d^{-1}\omega_i$。因为对同一个着色点来说，对任何点光源$M_s^{-1}$和$M_d^{-1}$是定值，所以：
\begin{equation}
\label{eq:FinalEquation4MPL}
L_o=|M_s^{-1}|\sum_{\omega_i}\frac{\omega_s.z}{(\omega_s\cdot\omega_s)^2}L_i+|M_d^{-1}|\sum_{\omega_i}\frac{\omega_d.z}{(\omega_d\cdot\omega_d)^2}L_i
\end{equation}

而使用BRDF方式来计算多点光源光照的公式如下：
\begin{equation}
\label{eq:BRDFFinalEquation4MPL}
L_o=\sum_{\omega_i}(f_d+\frac{DFG}{4(\omega_o\cdot n)(\omega_i\cdot n)})L_in\cdot\omega_i
\end{equation}
其中$D$、$F$、$G$、$f_d$需要分别按照式\ref{eq:GGXD}、\ref{eq:Fresnel}、\ref{eq:GeometryShadow}、\ref{eq:DisneyDiffuse}来计算。

从式\ref{eq:FinalEquation4MPL}、\ref{eq:BRDFFinalEquation4MPL}可以看出，本文用LTC的方式来实现多点光源光照，计算量比使用BRDF方式要少很多，从而达到本文要实现的目标：以更快的速率实现多点光源下基于物理的光照效果。除此之外，使用本文LTC渲染点光源的方法，不会因为BRDF公式（$DFG$以及$f_d$项）的复杂性而增加渲染时间， 也就是说，即使未来BRDF因为要达到更加物理真实的效果而变得更加复杂，使用本文的方法是不会降低渲染帧率的。本文算法对于点光源在基于物理的渲染上具有很好的可扩展性。甚至可以让复杂的点光源PBR光照在移动平台上也能快速实现出较好的效果。

\subsection{光源裁剪}
按照上述的方法，当变换前和变换后的的光源位置均处于微平面以上时，使用LTC和BRDF方法的效果相似。如图\ref{fig:LightClip}中$(a)$和$(b)$，其中光源初始位置为$(0, 0, 1)$，地面粗糙度为$\alpha=0.5$。
但是有可能会在以下两种情况下出现光照异常：
\subsubsection{在光源做线性变换之前进行光源裁剪}
当点光源的初始位置于点P所在半球面以下，而在乘上变换矩阵${M}^{-1}$ 后，光源位置移动到半球面以上，如图\ref{fig:LightClip}中的$(c)$和$(d)$。

\begin{figure}[h]
    \centering
	\subfigure[正常情况下使用LTC方法计算单个点光源]{
		\begin{minipage}[t]{0.45\linewidth}
			\centering
			\includegraphics[width=1.0\linewidth]{LTCPointLight_0_5_and_1_0.png}
		\end{minipage}
    }
    \subfigure[正常情况下使用BRDF方法计算单个点光源]{
		\begin{minipage}[t]{0.45\linewidth}
			\centering
			\includegraphics[width=1.0\linewidth]{BRDFPointLight_0_5_and_1_0.png}
		\end{minipage}
    }

    \subfigure[当点光源在着色点切平面以下，并且不做第一次裁剪时使用LTC方法计算光照]{
		\begin{minipage}[t]{0.45\linewidth}
			\centering
			\includegraphics[width=1.0\linewidth]{LTCPointLight_0_5_and_-0_15.png}
		\end{minipage}
    }
    \subfigure[当点光源在着色点切平面以下时，使用BRDF方法计算光照]{
		\begin{minipage}[t]{0.45\linewidth}
			\centering
			\includegraphics[width=1.0\linewidth]{BRDFPointLight_0_5_and_-0_15.png}
		\end{minipage}
    }
    \captionsetup{font={small}}
    \caption{第一次光源裁剪}
	\label{fig:FirstLightClip}
\end{figure}

按照实际中的真实效果，当点光源位于平面以下时，平面表面应当无任何光照效果。但是从图\ref{fig:FirstLightClip}中的$(c)$和$(d)$，其中光源初始位置为$(0, 0, -0.158731)$，地面粗糙度为$\alpha=0.5$，可以看出使用LTC 的方法在平面上有明显的“漏光”，这是因为本文的变换矩阵$M$在拟合时事先假定光源初始时一定处于切平面以上。如果光源初始时处于切平面以下，按照式\ref{eq:SpecularOmega} 和\ref{eq:DiffuseOmega}，乘上矩阵$M$之后，光源有可能被变换到切平面以上（即$\omega_s.z > 0$或$\omega_d.z > 0$），导致漏光现象的出现。所以对于这类光源，我们需要在计算光照前先将其裁剪去掉。

\subsubsection{在光源做线性变换之后进行光源裁剪}
当点光源的初始位置于点P所在半球面以上，而在乘上变换矩阵${M}^{-1}$ 后，光源位置有可能变换到半球面以下，导致$\omega_s.z < 0$或$\omega_d.z < 0$。但是本文在拟合BRDF分布时用的是式\ref{eq:ClampedCosine}中的截断余弦分布，在半球面以下分布的值应该为0，所以需要在光源变换之后再做一次裁剪，保证式\ref{eq:FinalEquation4SPL}不会算出负的$L_o$。如果不做该次裁剪，在单点光源光照下正常（因为负值的出射辐射度在输出到颜色缓冲区时被截断为0），但是在多点光源光照下会出现不正常的结果，如图\ref{fig:SecondLightClip}所示：
\begin{figure}[h]
    \centering
	\subfigure[不做第二次裁剪时使用LTC方法计算多个点光源光照]{
		\begin{minipage}[t]{0.45\linewidth}
			\centering
			\includegraphics[width=1.0\linewidth]{NoSecondClip.png}
		\end{minipage}
    }
    \subfigure[做第二次裁剪时使用LTC方法计算多个点光源光照]{
		\begin{minipage}[t]{0.45\linewidth}
			\centering
			\includegraphics[width=1.0\linewidth]{WithSecondClip.png}
		\end{minipage}
    }
    \captionsetup{font={small}}
    \caption{第二次光源裁剪}
	\label{fig:SecondLightClip}
\end{figure}

综上，加上两次光源裁剪之后的式\ref{eq:FinalEquation4MPL}更新为：
\begin{equation}
    L_o=
    \begin{cases}
    0, &\omega_i\cdot n<0 \\
    |M_s^{-1}|\sum_{\omega_i}\frac{max(\omega_s.z,0)}{(\omega_s\cdot\omega_s)^2}L_i+|M_d^{-1}|\sum_{\omega_i}\frac{max(\omega_d.z,0)}{(\omega_d\cdot\omega_d)^2}L_i, &\omega_i\cdot n>0
    \end{cases}
\end{equation}

\subsection{实验结果}
本文的实验环境是：Intel(R)Xeon(R)CPU E3-1230 V2@3.30GHz，16GB内存，NVIDIA GeForce GTX 1060 6GB显卡。

在有100个点光源的场景中，使用BRDF方式以及本文的算法在场景粗糙度$\alpha=0.27$时所实现的渲染结果如图\ref{fig:BRDFResultAndLTCResult}所示：
%\begin{figure}
%	\centering
%	\includegraphics[width=1.0\columnwidth]{BRDFResult.png}
%    \captionsetup{font={small}}
%	\caption{使用BRDF方式渲染的结果}
%	\label{fig:BRDFResult}
%\end{figure}
%
%\begin{figure}
%	\centering
%	\includegraphics[width=1.0\columnwidth]{LTCResult.png}
%    \captionsetup{font={small}}
%	\caption{使用本文算法渲染的结果}
%	\label{fig:LTCResult}
%\end{figure}
\begin{figure}
	\centering
    \subfigure[使用BRDF方式渲染的结果]{
		\begin{minipage}[t]{1.0\linewidth}
			\centering
			\includegraphics[width=1.0\linewidth]{BRDFResult.png}
		\end{minipage}
    }
    \subfigure[使用本文算法渲染的结果]{
		\begin{minipage}[t]{1.0\linewidth}
			\centering
			\includegraphics[width=1.0\linewidth]{LTCResult.png}
		\end{minipage}
    }
    \captionsetup{font={small}}
    \caption{使用BRDF和本文算法结果的对比}
    \label{fig:BRDFResultAndLTCResult}
\end{figure}

当渲染不同数量的光源时，使用BRDF方式以及本文算法的帧率和提升的渲染时间如表\ref{tab:TimeConsuming}所示：
\begin{table}[!h]
    \centering
    \begin{tabular}{|l|c|c|c|c|}
          \hline
           & 100个光源 & 500个光源 & 1000个光源 & 5000个光源 \\
          \hline
          BRDF帧率(fps) & 118 & 23 & 12 & 2 \\
          \hline
          本文算法帧率(fps) & 285 & 56 & 28 & 5 \\
          \hline
          本文算法时间提升(ms) & 4.97 & 25.62 & 47.62 & 255.49 \\
          \hline
    \end{tabular}
    \caption{本文算法以及BRDF的渲染效率}
    \label{tab:TimeConsuming}
\end{table}

\bibliographystyle{plain}%
\bibliography{LTC_bibfile}

\end{document}
